using Autodesk.Navisworks.Api.Plugins;
using Autodesk.Navisworks.Api;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using static NavisWorksInfoTools.Constants;
using ComApi = Autodesk.Navisworks.Api.Interop.ComApi;
using ComApiBridge = Autodesk.Navisworks.Api.ComApi;
using Win = System.Windows;
using static Common.ExceptionHandling.ExeptionHandlingProcedures;
using System.IO;
using WinForms = System.Windows.Forms;
using System.Xml.Serialization;
using NavisWorksInfoTools.S1NF0_SOFTWARE.XML.St;
using NavisWorksInfoTools.S1NF0_SOFTWARE.XML.Cl;

//TODO: Подсветка невыбранных

//TODO: На будущее: учесть то, что текущий документ может меняться, могут переоткрываться другие документы.
//если в нэвисе открыли другой документ или текущий документ изменился как угодно, то все изменения должны сбрасываться

namespace NavisWorksInfoTools.S1NF0_SOFTWARE
{
    public class DataStorage
    {
        public const string NEW_CLASS_NAME = "Autogenerated";
        public const string NEW_CLASS_NAME_IN_PLURAL = "Autogenerated classes";

        private Document doc = null;
        string stPath = null;
        string clPath = null;
        ComApi.InwOpState3 oState = null;
        public Structure Structure { get; set; } = null;
        private Classifier classifier = null;

        public string DefDetailLevel = "DefaultLevel";

        /// <summary>
        /// Класс, к которому будут отнесены объекты, не содержащие свойств
        /// </summary>
        public Class DefClassWithNoProps { get; private set; } = null;

        /// <summary>
        /// Ключ - название всех свойств, отсортированных по алфавиту и срощенных в одну строку
        /// </summary>
        public Dictionary<string, Class> ClassLookUpByProps { get; private set; } = new Dictionary<string, Class>();

        /// <summary>
        /// Ключ - код класса
        /// </summary>
        public Dictionary<string, Class> ClassLookUpByCode { get; private set; } = new Dictionary<string, Class>();


        //TODO: Учесть, что id может быть не строкой
        // Поиск ID с помощью Search API Navis
        //private Search searchForID = null;
        //private SearchCondition baseSearchCondition = null;
        //Поиск ID по словарю
        /// <summary>
        /// Словарь всех элементов геометрии модели по их id
        /// </summary>
        private Dictionary<string, ModelItem> modelItemDictionary = null;

        /// <summary>
        /// Ключ - ID
        /// </summary>
        public Dictionary<string, XML.St.Object> GeometryObjectLookUp { get; private set; } = new Dictionary<string, XML.St.Object>();


        public StructureWindow StructureWindow { get; set; } = null;
        public DataStorage(Document doc, string stPath, string clPath, Structure structure, Classifier classifier)
        {
            this.doc = doc;
            this.stPath = stPath;
            this.clPath = clPath;
            this.oState = ComApiBridge.ComApiBridge.State;
            this.Structure = structure;
            this.classifier = classifier;

            //Все новые классы будут создаваться на одном DetailLevel
            if (classifier.DetailLevels.Count > 0)
            {
                DefDetailLevel = classifier.DetailLevels.First();
                if (String.IsNullOrWhiteSpace(DefDetailLevel))
                {
                    throw new Exception("Первый DetailLevel должен быть не пустой строкой");
                }
            }
            else
            {
                classifier.DetailLevels.Add(DefDetailLevel);
            }

            //Построить словари для быстрого поиска классов
            foreach (Class c in classifier.NestedClasses)
            {
                SurveyClass(c);
            }

            //Всегда должен быть DefaultClass
            if (DefClassWithNoProps == null)
            {
                DefClassWithNoProps = CreateNewClass("DefaultClass", "DefaultClasses");
            }


            //Объект поиска объектов по документу Navis
            //Search API
            //searchForID = new Search();
            //searchForID.Selection.SelectAll();
            //NamedConstant tabCN = new NamedConstant("LcOaPropOverrideCat", S1NF0_DATA_TAB_DISPLAY_NAME);
            //NamedConstant idCN = new NamedConstant(ID_PROP_DISPLAY_NAME, ID_PROP_DISPLAY_NAME);
            //baseSearchCondition = SearchCondition.HasPropertyByCombinedName(tabCN, idCN);

            //Быстрее работает поиск по словарю
            modelItemDictionary = new Dictionary<string, ModelItem>();
            //Все объекты модели с id поместить в один словарь
            ModelItemEnumerableCollection allItems = doc.Models.RootItemDescendantsAndSelf;
            foreach (ModelItem item in allItems)
            {
                if (item.HasGeometry)
                {
                    DataProperty idProp = item.PropertyCategories
                                .FindPropertyByDisplayName(S1NF0_DATA_TAB_DISPLAY_NAME,
                                ID_PROP_DISPLAY_NAME);
                    if (idProp != null)
                    {
                        string key = Utils.GetDisplayValue(idProp.Value);
                        if (!modelItemDictionary.ContainsKey(key))
                        {
                            modelItemDictionary.Add(key, item);
                        }
                    }
                }
            }

            //Обход всех объектов
            //Просмотреть все объекты, не имеющие вложенных. Какие из них уже присутствуют в документе?
            //Построить словарь для быстрого поиска объектов, уже добавленных в дерево
            List<XML.St.Object> nestedObjectsValid; List<XML.St.Object> geometryObjectsCurrDoc;
            List<XML.St.Object> geometryObjectsOtherDoc; List<XML.St.Object> displayObjects;
            List<XML.St.Object> resetObjects;
            SurveyNestedObjects(structure.NestedObjects,
                out nestedObjectsValid, out geometryObjectsCurrDoc,
                out geometryObjectsOtherDoc, out displayObjects, out resetObjects);
            structure.NestedObjects = nestedObjectsValid;

            //Если какие-то объекты уже присутствуют в дереве, то уточнить набор свойств и класс для них согласно модели Navis
            foreach (XML.St.Object o in GeometryObjectLookUp.Values)
            {
                PropertyCategoryCollection categories = o.NavisItem.PropertyCategories;

                SetObjectProps(o, categories);

            }

            //Создать окно и заполнить TreeView. НЕ СОЗДАВАТЬ.
            //ОКНО НЕЛЬЗЯ ИСПОЛЬЗОВАТЬ ПОВТОРНО ПОСЛЕ ЗАКРЫТИЯ - https://stackoverflow.com/questions/3568233/wpf-cannot-reuse-window-after-it-has-been-closed
            StructureWindow = new StructureWindow(this);
        }


        /// <summary>
        /// УДАЛЕНИЕ ДУБЛИКАТОВ СВОЙСТВ
        /// Обход классов. Заполнение словарей для быстрого поиска классов
        /// </summary>
        /// <param name="class"></param>
        private void SurveyClass(Class @class)
        {
            @class.DeleteDuplicateProps();
            if (!String.IsNullOrWhiteSpace(@class.Code))//Классы без кода останутся но не попадают в словари
            {
                ClassLookUpByCode.Add(@class.Code, @class);

                if (@class.Properties.Count > 0)
                {
                    string key = GetClassKey(@class.Properties);

                    //Если есть 2 класса с одинаковым набором свойств, то словаре будет только один из них
                    if (!ClassLookUpByProps.ContainsKey(key))
                        ClassLookUpByProps.Add(key, @class);
                }
                else if (DefClassWithNoProps == null && @class.Name.Equals("DefaultClass"))
                {
                    DefClassWithNoProps = @class;
                }

            }

            foreach (Class nestedClass in @class.NestedClasses)
            {
                SurveyClass(nestedClass);
            }
        }


        private enum SurveyObjectResult
        {
            RegularObject,
            GeometryObjectCurrDoc,
            GeometryObjectOtherDoc,
            InvalidObject
        }

        /// <summary>
        /// УДАЛЕНИЕ ДУБЛИКАТОВ СВОЙСТВ
        /// Обход объектов. Объекты геометрии текущего документа попадают в словарь
        /// </summary>
        /// <param name="object"></param>
        /// <returns></returns>
        private SurveyObjectResult SurveyObject(XML.St.Object @object)
        {
            @object.DeleteDuplicateProps();
            SurveyObjectResult result = SurveyObjectResult.RegularObject;
            if (String.IsNullOrEmpty(@object.Name) || String.IsNullOrEmpty(@object.ClassCode))
            {
                result = SurveyObjectResult.InvalidObject;
            }
            else if (@object.NestedObjects.Count == 0 && !String.IsNullOrEmpty(@object.SceneObjectId))
            {
                string[] splitted = @object.SceneObjectId.Split('|');
                if (splitted.Length > 1)
                {
                    string id = splitted[1];

                    if (GeometryObjectLookUp.ContainsKey(id))
                    {
                        //Если есть объекты с дублирующимися id, то их нужно будет удалить
                        result = SurveyObjectResult.InvalidObject;
                    }
                    else
                    {
                        ModelItem item = SearchForIDInCurrDoc(id);
                        if (item != null && item.HasGeometry)
                        {
                            //Это объект геометрии этого документа
                            @object.NavisItem = item;
                            GeometryObjectLookUp.Add(id, @object);
                            result = SurveyObjectResult.GeometryObjectCurrDoc;
                        }
                        else
                        {
                            //Видимо это объект геометрии добавленный в другом документе
                            result = SurveyObjectResult.GeometryObjectOtherDoc;
                        }
                    }
                }
            }

            if (result == SurveyObjectResult.RegularObject)
            {
                List<XML.St.Object> nestedObjectsValid;
                List<XML.St.Object> geometryObjectsCurrDoc;
                List<XML.St.Object> geometryObjectsOtherDoc;
                List<XML.St.Object> displayObjects;
                List<XML.St.Object> resetObjects;
                SurveyNestedObjects(@object.NestedObjects,
                    out nestedObjectsValid, out geometryObjectsCurrDoc,
                    out geometryObjectsOtherDoc, out displayObjects, out resetObjects);

                @object.NestedObjects = nestedObjectsValid;
                @object.NestedDisplayObjects = displayObjects;//больше не поменяются
                @object.NestedGeometryObjectsCurrDoc = geometryObjectsCurrDoc;
                @object.NestedGeometryObjectsOtherDoc = geometryObjectsOtherDoc;//больше не поменяются
                @object.ResetNestedObjects = resetObjects;//больше не поменяются
            }

            return result;
        }



        private void SurveyNestedObjects(List<XML.St.Object> nestedObjects,
            out List<XML.St.Object> nestedObjectsValid,
            out List<XML.St.Object> geometryObjectsCurrDoc,
            out List<XML.St.Object> geometryObjectsOtherDoc,
            out List<XML.St.Object> displayObjects,
            out List<XML.St.Object> resetObjects)
        {
            nestedObjectsValid = new List<XML.St.Object>();
            geometryObjectsCurrDoc = new List<XML.St.Object>();
            geometryObjectsOtherDoc = new List<XML.St.Object>();
            displayObjects = new List<XML.St.Object>();
            resetObjects = new List<XML.St.Object>();
            foreach (XML.St.Object nestedObject in nestedObjects)
            {
                switch (SurveyObject(nestedObject))
                {
                    case SurveyObjectResult.RegularObject:
                        nestedObjectsValid.Add(nestedObject);
                        displayObjects.Add(nestedObject);
                        resetObjects.Add(nestedObject);
                        break;
                    case SurveyObjectResult.GeometryObjectCurrDoc:
                        nestedObjectsValid.Add(nestedObject);
                        geometryObjectsCurrDoc.Add(nestedObject);
                        break;
                    case SurveyObjectResult.GeometryObjectOtherDoc:
                        nestedObjectsValid.Add(nestedObject);
                        geometryObjectsOtherDoc.Add(nestedObject);
                        resetObjects.Add(nestedObject);
                        break;
                    case SurveyObjectResult.InvalidObject:
                        break;
                }

            }
        }



        private ModelItem SearchForIDInCurrDoc(string guid)
        {
            //Search API
            //VariantData oData = VariantData.FromDisplayString(guid);
            //SearchCondition searchForIDCondition = baseSearchCondition.EqualValue(oData);
            ////searchForGUID.SearchConditions.Clear();
            //searchForID.SearchConditions.CopyFrom(new SearchConditionCollection() { searchForIDCondition });

            //return searchForID.FindFirst(doc, false);

            ModelItem item = null;
            modelItemDictionary.TryGetValue(guid, out item);
            return item;
        }

        /// <summary>
        /// Заполнение свойств объекта в соответствии с классами. Присвоение ссылки на класс
        /// </summary>
        /// <param name="obj"></param>
        /// <param name="categories"></param>
        private void SetObjectProps(XML.St.Object obj, PropertyCategoryCollection categories)
        {
            List<XML.Cl.Property> clProps = null;
            List<XML.St.Property> stProps = null;
            string actualKey = AnalizeNavisProps(categories, out clProps, out stProps);

            //Сначала присвоить правильный класс
            Class @class = null;
            //Проверить есть ли у объекта уже ссылка на класс
            if (!String.IsNullOrEmpty(obj.ClassCode))
            {
                //Найти этот класс
                ClassLookUpByCode.TryGetValue(obj.ClassCode, out @class);
                if (@class != null)
                {
                    //Если класс есть, то проверить его свойства
                    string currKey = GetClassKey(@class.Properties);
                    if (currKey == null || !currKey.Equals(actualKey))
                    {
                        //Если этот класс не подходит по свойствам, то он должен быть переназначен
                        @class = null;
                    }
                }
            }

            if (@class == null)
            {
                //Проверить есть ли класс подходящий по свойствам
                if (actualKey == null)
                {
                    //Свойств нет - присвоить дефолный класс без свойств
                    @class = DefClassWithNoProps;
                }
                else
                {
                    //Поиск существующего класса подходящего по свойствам
                    ClassLookUpByProps.TryGetValue(actualKey, out @class);
                    if (@class == null)
                    {
                        //Подходящий класс не найден. Создать его
                        @class = CreateNewClass(NEW_CLASS_NAME, NEW_CLASS_NAME_IN_PLURAL, actualKey, clProps);
                    }
                }
            }

            //Присвоить объекту ссылку на актуальный класс
            obj.ClassCode = @class.Code;

            //Задать свойства для объекта
            obj.Properties = stProps;
        }

        /// <summary>
        /// Создает класс и добавляет его во все нужные словари
        /// </summary>
        /// <param name="Name"></param>
        /// <param name=""></param>
        /// <returns></returns>
        private Class CreateNewClass(string name, string nameInPlural, string propKey = null, List<XML.Cl.Property> clProps = null)
        {
            string code = GetUniqueClassCode();
            Class @class = new Class()
            { Name = name, NameInPlural = nameInPlural, DetailLevel = DefDetailLevel, Code = code };
            ClassLookUpByCode.Add(code, @class);
            classifier.NestedClasses.Add(@class);

            if (propKey != null && clProps != null)
            {
                @class.Properties = clProps;
                ClassLookUpByProps.Add(propKey, @class);
            }

            return @class;
        }


        private static string GetClassKey(List<XML.Cl.Property> clProps)
        {
            string key = null;

            if (clProps.Count > 0)
            {
                //может сортироваться прямо в самом классе
                clProps.Sort();
                key = String.Join("", clProps);
            }

            return key;
        }

        /// <summary>
        /// Возвращает ключ для словаря посика класса по набору свойств Navis
        /// </summary>
        /// <param name="categories"></param>
        /// <param name="clProps"></param>
        /// <param name="stProps"></param>
        /// <returns></returns>
        private static string AnalizeNavisProps(PropertyCategoryCollection categories,
            out List<XML.Cl.Property> clProps, out List<XML.St.Property> stProps)
        {
            clProps = new List<XML.Cl.Property>();
            stProps = new List<XML.St.Property>();

            foreach (PropertyCategory c in categories)
            {
                if (c.Name.Equals("LcOaPropOverrideCat")
                    && c.DisplayName != S1NF0_DATA_TAB_DISPLAY_NAME)
                {
                    foreach (DataProperty p in c.Properties)
                    {
                        clProps.Add(new XML.Cl.Property() { Name = p.DisplayName, Tag = c.DisplayName });
                        stProps.Add(new XML.St.Property() { Name = p.DisplayName, Value = Utils.GetDisplayValue(p.Value) });
                    }
                }
            }
            //СВОЙСТВА МОГУТ ИМЕТЬ ОДИНАКОВЫЕ ИМЕНА. В МЯКИШЕ ВСЕ ИМЕНА ДОЛЖНЫ БЫТЬ РАЗНЫМИ
            //Удалить дубликаты
            clProps = (new SortedSet<XML.Cl.Property>(clProps)).ToList();
            stProps = (new SortedSet<XML.St.Property>(stProps)).ToList();


            clProps.Sort();
            return GetClassKey(clProps);
        }


        private string GetUniqueClassCode()
        {
            int n = 1;
            while (ClassLookUpByCode.ContainsKey(n.ToString()))
            {
                n++;
            }
            return n.ToString();
        }


        /// <summary>
        /// ВЫЗЫВАЕТСЯ НАЖАТИЕМ КНОПКИ В ОКНЕ
        /// Создает новый объект в дереве структуры и добавляет в словарь
        /// </summary>
        /// <param name="parent"></param>
        /// <param name="item"></param>
        public void CreateNewObject(XML.St.Object parent, ModelItem item)
        {
            string replacementName, baseName, strId;
            bool contains = ItemAdded(item, out baseName, out replacementName, out strId);
            if (!contains)//Добавлять только если объект еще не был добавлен
            {
                XML.St.Object @object = new XML.St.Object()
                {
                    Name = replacementName,//baseName,//Из-за бага мякиша приходится писать в имя все целиком вместе с id
                    SceneObjectId = replacementName,
                    NavisItem = item,
                };

                //Настрока ссылки на класс и заполнение списка свойств в соответствии со свойствами Navis
                SetObjectProps(@object, item.PropertyCategories);

                //Добавление в соответствующие списки родителя
                parent.NestedObjects.Add(@object);
                parent.NestedGeometryObjectsCurrDoc.Add(@object);
                //Добавление в словарь поиска по id
                GeometryObjectLookUp.Add(strId, @object);
                parent.NotifyPropertyChanged();
            }

        }

        public bool ItemAdded(ModelItem item, out string baseName, out string replacementName, out string strId)
        {
            baseName = null;
            bool baseNameTrustable;
            object id;
            FBXExport3.CreateReplacementName(oState, item, out baseName, out baseNameTrustable, out replacementName, out id);

            strId = id.ToString();
            return GeometryObjectLookUp.ContainsKey(strId);
        }


        /// <summary>
        /// ВЫЗЫВАЕТСЯ НАЖАТИЕМ КНОПКИ В ОКНЕ
        /// Очистить узел от добавленных к нему объектов геометрии Navis
        /// </summary>
        /// <param name="parent"></param>
        public void ResetNestedObjects(XML.St.Object parent)
        {
            foreach (XML.St.Object obj in parent.NestedGeometryObjectsCurrDoc)
            {
                //Каждый объект геометрии удалить из словаря
                string[] splitted = obj.SceneObjectId.Split('|');
                string id = splitted[1];
                GeometryObjectLookUp.Remove(id);
            }
            //Сброс списка вложенных
            parent.NestedObjects = new List<XML.St.Object>(parent.ResetNestedObjects);
            //Очистить список объектов геометрии
            parent.NestedGeometryObjectsCurrDoc = new List<XML.St.Object>();
            parent.NotifyPropertyChanged();
        }

        /// <summary>
        /// ВЫЗЫВАЕТСЯ НАЖАТИЕМ КНОПКИ В ОКНЕ
        /// Выбрать в документе все объекты геометрии, которые еще не добавлены в структуру
        /// </summary>
        public void SelectNotAdded()
        {
            ModelItemEnumerableCollection allItems = doc.Models.RootItemDescendantsAndSelf;
            ModelItemCollection toSelect = new ModelItemCollection();
            foreach (ModelItem item in allItems)
            {
                if (item.HasGeometry)
                {
                    DataProperty idProp = item.PropertyCategories
                                .FindPropertyByDisplayName(S1NF0_DATA_TAB_DISPLAY_NAME,
                                ID_PROP_DISPLAY_NAME);
                    if (idProp != null)
                    {
                        string key = Utils.GetDisplayValue(idProp.Value);
                        if (!GeometryObjectLookUp.ContainsKey(key))
                        {
                            toSelect.Add(item);
                        }
                    }
                }
            }
            doc.CurrentSelection.CopyFrom(toSelect);
        }

        /// <summary>
        /// ВЫЗЫВАЕТСЯ НАЖАТИЕМ КНОПКИ В ОКНЕ
        /// Сериализация структуры и классификатора
        /// </summary>
        public void SerializeStruture()
        {
            //TODO: Перед сериализацией убедиться, что  во всех объектах и во всех классах нет дублирующихся свойств
            string stDir = Path.GetDirectoryName(stPath);
            string stName = Path.GetFileNameWithoutExtension(stPath);
            if (stPath.EndsWith(".st.xml"))
            {
                stName = Path.GetFileNameWithoutExtension(stName);
            }
            string stSavePath = Common.Utils.GetNonExistentFileName(stDir, stName, "st.xml");

            string clDir = Path.GetDirectoryName(clPath);
            string clName = Path.GetFileNameWithoutExtension(clPath);
            if (clPath.EndsWith(".cl.xml"))
            {
                clName = Path.GetFileNameWithoutExtension(clName);
            }
            string clSavePath = Common.Utils.GetNonExistentFileName(clDir, clName, "cl.xml");

            XmlSerializer xmlSerializer = new XmlSerializer(typeof(Structure));
            using (StreamWriter sw = new StreamWriter(stSavePath))
            {
                xmlSerializer.Serialize(sw, Structure);
            }

            xmlSerializer = new XmlSerializer(typeof(Classifier));
            using (StreamWriter sw = new StreamWriter(clSavePath))
            {
                xmlSerializer.Serialize(sw, classifier);
            }
        }





    }
}
